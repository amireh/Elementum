namespace Ogre {
  typedef unsigned char uchar;
  typedef unsigned short ushort;
  typedef unsigned int uint;
	typedef unsigned long ulong;
  typedef float Real;
  typedef std::string String;

  typedef uint32 RGBA;
  typedef uint32 ARGB;
  typedef uint32 ABGR;
	typedef uint32 BGRA;

  typedef int uint8;


  typedef map<String, String> NameValuePairList;


  enum FogMode
  {
      FOG_NONE,
      FOG_EXP,
      FOG_EXP2,
      FOG_LINEAR
  };

  enum CullingMode
  {
      /// Hardware never culls triangles and renders everything it receives.
      CULL_NONE = 1,
      /// Hardware culls triangles whose vertices are listed clockwise in the view (default).
      CULL_CLOCKWISE = 2,
      /// Hardware culls triangles whose vertices are listed anticlockwise in the view.
      CULL_ANTICLOCKWISE = 3
  };

  enum ManualCullingMode
  {
      /// No culling so everything is sent to the hardware.
      MANUAL_CULL_NONE = 1,
      /// Cull triangles whose normal is pointing away from the camera (default).
      MANUAL_CULL_BACK = 2,
      /// Cull triangles whose normal is pointing towards the camera.
      MANUAL_CULL_FRONT = 3
  };

  enum ShadowTechnique
  {
    SHADOWTYPE_NONE = 0x00,
		SHADOWDETAILTYPE_ADDITIVE = 0x01,
		SHADOWDETAILTYPE_MODULATIVE = 0x02,
		SHADOWDETAILTYPE_INTEGRATED = 0x04,
		SHADOWDETAILTYPE_STENCIL = 0x10,
		SHADOWDETAILTYPE_TEXTURE = 0x20,
    SHADOWTYPE_STENCIL_MODULATIVE = 0x12,
    SHADOWTYPE_STENCIL_ADDITIVE = 0x11,
    SHADOWTYPE_TEXTURE_MODULATIVE = 0x22,
    SHADOWTYPE_TEXTURE_ADDITIVE = 0x21,
		SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED = 0x25,
		SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED = 0x26
  };

  enum PolygonMode
  {
    /// Only points are rendered.
    PM_POINTS = 1,
    /// Wireframe models are rendered.
    PM_WIREFRAME = 2,
    /// Solid polygons are rendered.
    PM_SOLID = 3
  };


  enum RenderQueueGroupID
  {
    /// Use this queue for objects which must be rendered first e.g. backgrounds
    RENDER_QUEUE_BACKGROUND = 0,
    /// First queue (after backgrounds), used for skyboxes if rendered first
    RENDER_QUEUE_SKIES_EARLY = 5,
    RENDER_QUEUE_1 = 10,
    RENDER_QUEUE_2 = 20,
    RENDER_QUEUE_WORLD_GEOMETRY_1 = 25,
    RENDER_QUEUE_3 = 30,
    RENDER_QUEUE_4 = 40,
    /// The default render queue
    RENDER_QUEUE_MAIN = 50,
    RENDER_QUEUE_6 = 60,
    RENDER_QUEUE_7 = 70,
    RENDER_QUEUE_WORLD_GEOMETRY_2 = 75,
    RENDER_QUEUE_8 = 80,
    RENDER_QUEUE_9 = 90,
    /// Penultimate queue(before overlays), used for skyboxes if rendered last
    RENDER_QUEUE_SKIES_LATE = 95,
    /// Use this queue for objects which must be rendered last e.g. overlays
    RENDER_QUEUE_OVERLAY = 100,
    /// Final possible render queue, don't exceed this
    RENDER_QUEUE_MAX = 105
  };

  class Vector2 {
    public:
    Real x,y;

    Vector2( const Real fX, const Real fY );
    Vector2( const Real scalar );
  }

  class Vector3 {
    public:

    Real x, y, z;
    static const Vector3 ZERO;
    static const Vector3 UNIT_X;
    static const Vector3 UNIT_Y;
    static const Vector3 UNIT_Z;
    static const Vector3 NEGATIVE_UNIT_X;
    static const Vector3 NEGATIVE_UNIT_Y;
    static const Vector3 NEGATIVE_UNIT_Z;
    static const Vector3 UNIT_SCALE;
    Vector3( const Real fX, const Real fY, const Real fZ );
    Vector3( const Real scalar );
  };

  class Degree {
    public:

    Degree(float f);
		Real valueDegrees() const;
		Real valueRadians() const;
		Real valueAngleUnits() const;
  };

  class Radian
	{
    public:

		Radian ( Real r=0 );
		Radian ( const Degree& d );

		Real valueDegrees() const;
		Real valueRadians() const;
		Real valueAngleUnits() const;

	};
	class Angle
	{

    public:

		Angle ( Real angle );
		operator Radian() const;
		operator Degree() const;
	};

  class Quaternion {
    public:

		inline Quaternion();
		inline Quaternion(Real fW,	Real fX, Real fY, Real fZ);
    inline Quaternion(const Radian& rfAngle, const Vector3& rkAxis);
    inline Quaternion(const Vector3& xaxis, const Vector3& yaxis, const Vector3& zaxis);
    inline Quaternion(const Vector3* akAxis);
  };

  class ColourValue
  {
    public:

    static const ColourValue ZERO;
    static const ColourValue Black;
    static const ColourValue White;
    static const ColourValue Red;
    static const ColourValue Green;
    static const ColourValue Blue;

    ColourValue( float red = 1.0f,
      float green = 1.0f,
      float blue = 1.0f,
      float alpha = 1.0f );
  };

  class Plane {
    public:

    Plane (const Vector3& rkNormal, Real fConstant);
    Plane (Real a, Real b, Real c, Real d);
  };

  class AxisAlignedBox {
    public:

		enum Extent
		{
			EXTENT_NULL,
			EXTENT_FINITE,
			EXTENT_INFINITE
		};

		typedef enum {
			FAR_LEFT_BOTTOM = 0,
			FAR_LEFT_TOP = 1,
			FAR_RIGHT_TOP = 2,
			FAR_RIGHT_BOTTOM = 3,
			NEAR_RIGHT_BOTTOM = 7,
			NEAR_LEFT_BOTTOM = 6,
			NEAR_LEFT_TOP = 5,
			NEAR_RIGHT_TOP = 4
		} CornerEnum;

    AxisAlignedBox();
    const Vector3& getSize() const;
  };

  class SubEntity {

  };

  class MovableObject {
    public:
    void setRenderQueueGroup(uint8 queueID);
    void setRenderQueueGroupAndPriority(uint8 queueID, ushort priority);
    const AxisAlignedBox& getBoundingBox(void) const;
    const String& getMovableType(void) const;

    virtual void setQueryFlags(int flags);
    virtual void setUserAny(const Any& anything);
    virtual const Any& getUserAny(void) const;

  };

  class Node
  {
    public:
    enum TransformSpace
    {
      TS_LOCAL,
      TS_PARENT,
      TS_WORLD
    };

    virtual void setPosition(const Vector3& pos);
    Vector3& getPosition() const;

    virtual void setScale(const Vector3& scale);
    virtual void setScale(Real x, Real y, Real z);
    virtual const Vector3 & getScale(void) const;

    virtual Node* createChild(
    const Vector3& translate = Vector3::ZERO,
    const Quaternion& rotate = Quaternion::IDENTITY );

    virtual Node* createChild(const String& name, const Vector3& translate = Vector3::ZERO, const Quaternion& rotate = Quaternion::IDENTITY);

    virtual void addChild(Node* child);

    virtual Node* getChild(unsigned short index) const;

    virtual Node* getChild(const String& name) const;
    virtual Node* removeChild(unsigned short index);
    virtual Node* removeChild(Node* child);

    virtual Node* removeChild(const String& name);

    virtual void removeAllChildren(void);

  };


  class Entity : public MovableObject {
    public:

		SubEntity* getSubEntity(unsigned int index) const;
		SubEntity* getSubEntity( const String& name ) const;
		unsigned int getNumSubEntities(void) const;
    void setDisplaySkeleton(bool display);
    const AxisAlignedBox& getWorldBoundingBox(bool derive = false) const;
    void setMaterialName( const String& name, const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );

    void setCastShadows(bool enabled);
    bool getCastShadows(void);

  };

  class SceneNode : public Node {
    public:


    void yaw(const Degree);
    void pitch(const Degree);
    void roll(const Degree);

    virtual void attachObject(MovableObject* obj);
    virtual unsigned short numAttachedObjects(void) const;
    virtual MovableObject* getAttachedObject(unsigned short index);
    virtual MovableObject* getAttachedObject(const String& name);
    virtual MovableObject* detachObject(unsigned short index);
    virtual void detachObject(MovableObject* obj);
    virtual MovableObject* detachObject(const String& name);
    virtual void detachAllObjects(void);

    SceneManager* getCreator(void) const;

    virtual SceneNode* createChildSceneNode(
        const Vector3& translate = Vector3::ZERO,
        const Quaternion& rotate = Quaternion::IDENTITY );
    virtual SceneNode* createChildSceneNode(const String& name, const Vector3& translate = Vector3::ZERO, const Quaternion& rotate = Quaternion::IDENTITY);

    virtual void removeAndDestroyChild(const String& name);

    virtual void removeAndDestroyChild(unsigned short index);
    virtual void removeAndDestroyAllChildren(void);

    virtual void showBoundingBox(bool bShow);
    virtual void hideBoundingBox(bool bHide);

    virtual void setDirection(
      Real x, Real y, Real z,
      TransformSpace relativeTo = TS_LOCAL,
      const Vector3& localDirectionVector = Vector3::NEGATIVE_UNIT_Z);

    virtual void setDirection(
      const Vector3& vec,
      TransformSpace relativeTo = TS_LOCAL,
      const Vector3& localDirectionVector = Vector3::NEGATIVE_UNIT_Z);
    virtual void lookAt(
      const Vector3& targetPoint,
      TransformSpace relativeTo,
      const Vector3& localDirectionVector = Vector3::NEGATIVE_UNIT_Z);

    virtual void setAutoTracking(
      bool enabled, SceneNode* target = 0,
      const Vector3& localDirectionVector = Vector3::NEGATIVE_UNIT_Z,
      const Vector3& offset = Vector3::ZERO);
    virtual SceneNode* getAutoTrackTarget(void);
		virtual const Vector3& getAutoTrackOffset(void);
		virtual const Vector3& getAutoTrackLocalDirection(void);

    SceneNode* getParentSceneNode(void) const;
    virtual void setVisible(bool visible, bool cascade = true);
    virtual void flipVisibility(bool cascade = true);

    virtual void setOrientation( const Quaternion& q );
    virtual void setOrientation( Real w, Real x, Real y, Real z);
  };

  class Light {
    public:
    /// Defines the type of light
    enum LightTypes
    {
        /// Point light sources give off light equally in all directions, so require only position not direction
        LT_POINT = 0,
        /// Directional lights simulate parallel light beams from a distant source, hence have direction but no position
        LT_DIRECTIONAL = 1,
        /// Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff
        LT_SPOTLIGHT = 2
    };

    Light();
    Light(const String& name);
    ~Light();

    void setType(LightTypes type);
    LightTypes getType(void) const;

    void setDiffuseColour(Real red, Real green, Real blue);
    void setDiffuseColour(const ColourValue& colour);
    const ColourValue& getDiffuseColour(void) const;

    void setSpecularColour(Real red, Real green, Real blue);
    void setSpecularColour(const ColourValue& colour);
    const ColourValue& getSpecularColour(void) const;

    void setAttenuation(Real range, Real constant, Real linear, Real quadratic);
    Real getAttenuationRange(void) const;
    Real getAttenuationConstant(void) const;
    Real getAttenuationLinear(void) const;
    Real getAttenuationQuadric(void) const;

    void setPosition(Real x, Real y, Real z);
    void setPosition(const Vector3& vec);
    const Vector3& getPosition(void) const;

    void setDirection(Real x, Real y, Real z);
    void setDirection(const Vector3& vec);
    const Vector3& getDirection(void) const;

    void setSpotlightRange(const Radian& innerAngle, const Radian& outerAngle, Real falloff = 1.0);
    const Radian& getSpotlightInnerAngle(void) const;
    const Radian& getSpotlightOuterAngle(void) const;
    Real getSpotlightFalloff(void) const;
    void setSpotlightInnerAngle(const Radian& val);
    void setSpotlightOuterAngle(const Radian& val);
    void setSpotlightFalloff(Real val);

		//void setSpotlightNearClipDistance(Real nearClip);
		//Real getSpotlightNearClipDistance() const;

		void setPowerScale(Real power);
		Real getPowerScale(void) const;

    const AxisAlignedBox& getBoundingBox(void) const;
    const String& getMovableType(void) const;
    const Vector3& getDerivedPosition(bool cameraRelativeIfSet = false) const;
    const Vector3& getDerivedDirection(void) const;

    void setVisible(bool visible);
  };

  class Camera {
    public:

    Camera( const Ogre::String& name, Ogre::SceneManager* sm);
    virtual ~Camera();

    SceneManager* getSceneManager(void) const;

    virtual void setAspectRatio(Real ratio);

    virtual void setNearClipDistance(Real nearDist);
    virtual Real getNearClipDistance(void) const;
    virtual void setFarClipDistance(Real farDist);
    virtual Real getFarClipDistance(void) const;

    void setPolygonMode(PolygonMode sd);
    PolygonMode getPolygonMode(void) const;

    void setPosition(Real x, Real y, Real z);
    void setPosition(const Vector3& vec);
    const Vector3& getPosition(void) const;

    void move(const Vector3& vec);
    void moveRelative(const Vector3& vec);

    void setDirection(Real x, Real y, Real z);
    void setDirection(const Vector3& vec);
    Vector3 getDirection(void) const;

    Vector3 getUp(void) const;
    Vector3 getRight(void) const;

    void lookAt( const Vector3& targetPoint );
    void lookAt(Real x, Real y, Real z);

    void roll(const Radian& angle);
    void yaw(const Radian& angle);
    void pitch(const Radian& angle);

    void rotate(const Vector3& axis, const Radian& angle);
    void rotate(const Quaternion& q);

    void setFixedYawAxis( bool useFixed, const Vector3& fixedAxis = Vector3::UNIT_Y );

    const Quaternion& getOrientation(void) const;
    void setOrientation(const Quaternion& q);
  };

  class StaticGeometry {

  };

  class InstancedGeometry {

  };

  class Renderable {
  };

  class RibbonTrail {

  };

  class SceneManager {
    public:

    virtual Camera* createCamera(const String& name);
    virtual Camera* getCamera(const String& name) const;
    virtual bool hasCamera(const String& name) const;
    virtual void destroyAllCameras(void);

    virtual Light* createLight(const String& name);
		virtual Light* createLight();
    virtual Light* getLight(const String& name) const;
		virtual bool hasLight(const String& name) const;


    void setAmbientLight(const ColourValue& colour);
    const ColourValue& getAmbientLight(void) const;

    virtual void setWorldGeometry(const String& filename);

    virtual void clearScene(void);

    virtual SceneNode* createSceneNode(void);
    virtual SceneNode* createSceneNode(const String& name);

    virtual void destroySceneNode(const String& name);
    virtual void destroySceneNode(SceneNode* sn);

    virtual SceneNode* getRootSceneNode(void);
    virtual SceneNode* getSceneNode(const String& name) const;
		virtual bool hasSceneNode(const String& name) const;

    virtual Entity* createEntity(
      const String& entityName,
      const String& meshName,
      const String& groupName = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME );
    virtual Entity* createEntity(const String& meshName);

    virtual Entity* getEntity(const String& name) const;
		virtual bool hasEntity(const String& name) const;
    virtual void destroyEntity(Entity* ent);
    virtual void destroyEntity(const String& name);
    virtual void destroyAllEntities(void);

    virtual void setSkyPlane(
        bool enable,
        const Plane& plane, const String& materialName, Real scale = 1000,
        Real tiling = 10, bool drawFirst = true, Real bow = 0,
        int xsegments = 1, int ysegments = 1,
        const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
		virtual void setSkyPlaneEnabled(bool enable);
		virtual bool isSkyPlaneEnabled(void) const;
		virtual SceneNode* getSkyPlaneNode(void) const;

    virtual void setSkyBox(
      bool enable, const String& materialName, Real distance = 5000,
      bool drawFirst = true, const Quaternion& orientation = Quaternion::IDENTITY,
      const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);

		virtual void setSkyBoxEnabled(bool enable);
		virtual bool isSkyBoxEnabled(void) const;
		virtual SceneNode* getSkyBoxNode(void) const;

    virtual void setSkyDome(
      bool enable, const String& materialName, Real curvature = 10,
      Real tiling = 8, Real distance = 4000, bool drawFirst = true,
      const Quaternion& orientation = Quaternion::IDENTITY,
      int xsegments = 16, int ysegments = 16, int ysegments_keep = -1,
      const String& groupName = ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);

    void setFog(
      FogMode mode = FOG_NONE, const ColourValue& colour = ColourValue::White,
      Real expDensity = 0.001, Real linearStart = 0.0, Real linearEnd = 1.0);

    virtual FogMode getFogMode(void) const;
    virtual const ColourValue& getFogColour(void) const;
    virtual Real getFogStart(void) const;
    virtual Real getFogEnd(void) const;
    virtual Real getFogDensity(void) const;

    // shadows
    virtual void setShadowTechnique(ShadowTechnique technique);
    virtual ShadowTechnique getShadowTechnique(void) const;
    virtual void setShadowColour(const ColourValue& colour);
    virtual const ColourValue& getShadowColour(void) const;

    // static geometry
		virtual StaticGeometry* createStaticGeometry(const String& name);
		virtual StaticGeometry* getStaticGeometry(const String& name) const;
		virtual bool hasStaticGeometry(const String& name) const;
		virtual void destroyStaticGeometry(StaticGeometry* geom);
		virtual void destroyStaticGeometry(const String& name);
		virtual void destroyAllStaticGeometry(void);

    // instanced geometry
		virtual InstancedGeometry* createInstancedGeometry(const String& name);
		virtual InstancedGeometry* getInstancedGeometry(const String& name) const;
		virtual void destroyInstancedGeometry(InstancedGeometry* geom);
		virtual void destroyInstancedGeometry(const String& name);
		virtual void destroyAllInstancedGeometry(void);

    // billboard chains & ribbon trails
    /*virtual BillboardChain* createBillboardChain(const String& name);
		virtual BillboardChain* createBillboardChain();
    virtual BillboardChain* getBillboardChain(const String& name) const;
		virtual bool hasBillboardChain(const String& name) const;

    virtual void destroyBillboardChain(BillboardChain* obj);
		virtual void destroyBillboardChain(const String& name);
		virtual void destroyAllBillboardChains(void);*/

    virtual RibbonTrail* createRibbonTrail(const String& name);
		virtual RibbonTrail* createRibbonTrail();
    virtual RibbonTrail* getRibbonTrail(const String& name) const;
		virtual bool hasRibbonTrail(const String& name) const;

    virtual void destroyRibbonTrail(RibbonTrail* obj);
		virtual void destroyRibbonTrail(const String& name);
		virtual void destroyAllRibbonTrails(void);

    // billboard sets
    virtual BillboardSet* createBillboardSet(const String& name, unsigned int poolSize = 20);

    virtual BillboardSet* createBillboardSet(unsigned int poolSize = 20);
    virtual BillboardSet* getBillboardSet(const String& name) const;
		virtual bool hasBillboardSet(const String& name) const;
    virtual void destroyBillboardSet(BillboardSet* set);
    virtual void destroyBillboardSet(const String& name);
    virtual void destroyAllBillboardSets(void);


  };

  class Viewport {
    public:

    void getActualDimensions( int &left, int &top, int &width, int &height ) const;
    Camera* getCamera(void) const;
    void setCamera(Camera* cam);

    Real getLeft(void) const;
    Real getTop(void) const;
    Real getWidth(void) const;
    Real getHeight(void) const;
    int getActualLeft(void) const;
    int getActualTop(void) const;
    int getActualWidth(void) const;
    int getActualHeight(void) const;

    void setBackgroundColour(const ColourValue& colour);
    const ColourValue& getBackgroundColour(void) const;
  };

  class MeshPtr {

  };

  class MeshManager {
    public:

    static MeshManager& getSingleton(void);

    MeshPtr createPlane(
      const String& name, const String& groupName, const Plane& plane,
      Real width, Real height,
      int xsegments = 1, int ysegments = 1,
      bool normals = true, unsigned short numTexCoordSets = 1,
      Real uTile = 1.0f, Real vTile = 1.0f, const Vector3& upVector = Vector3::UNIT_Y);
  };

  class ResourceGroupManager {
    public:

    static ResourceGroupManager& getSingleton(void);
		static String DEFAULT_RESOURCE_GROUP_NAME;
    static String INTERNAL_RESOURCE_GROUP_NAME;
		static String AUTODETECT_RESOURCE_GROUP_NAME;
		static size_t RESOURCE_SYSTEM_NUM_REFERENCE_COUNTS;

  };

  class ManualResourceLoader {
  };

  class Resource {

  };
  typedef Ogre::SharedPtr<Resource> ResourcePtr;

  class ResourceManager {

    virtual void remove(const String& name);
    bool resourceExists(const String& name);

    virtual
    ResourcePtr prepare(
      const String& name,
      const String& group);

    virtual
    ResourcePtr load(
      const String& name,
      const String& group);
  };

}
